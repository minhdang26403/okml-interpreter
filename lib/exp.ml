(* DO NOT EDIT THIS FILE *)


(* the type for primitive expressions, Base e *)
type base = 
  | Var of string (* program variable, x *)
  | Int of int (* int value, 5 *)
  | Bool of bool (* bool value, true *)
  | Unit (* unit value, () *)
  | Nil (* empty list, [] *)
  

(* the type for unary operators, UnOp (op, e) *)
type unOp = 
  | Not (* logical negation, not e *)
  | Neg (* numerical negation, - e *)
  | Fun of string (* anonymous function, fun x -> e *)
  | RecFun of string * string (* anonymous recursive function, value defined by let f x = e *)


(* the type for binary operators, BinOp (op, e1, e2) *)
type binOp = 
  | Add (* addition operator, e1 + e2 *)
  | Sub (* subtraction operator, e1 - e2 *)
  | Mul (* multiplication operator, e1 * e2 *)
  | Div (* division operator, e1 / e2 *)

  | Eq (* equality comparison, e1 = e2 *)
  | Neq (* inequality comparison, e1 <> e2 *)
  | Geq (* greater-than-or-equal comparison, e1 >= e2 *)
  | Leq (* less-than-or-equal comparison, e1 <= e2 *)
  | Gt (* greater-than comparison, e1 > e2 *)
  | Lt (* less-than comparison, e1 < e2 *)

  | And (* logical shortcircuiting and, e1 && e2 *)
  | Or (* logical shortcircuiting or, e1 || e2 *)

  | App (* function application, e1 e2 *)
  | Cons (* list cons, e1::e2 *)
  | Pair (* 2-tupling, (e1, e2) *)
  | MatchP of string * string (* pair matching, match e1 with (x,y) -> e2 *)

  | Let of string (* let binding, let x = e1 in e2 *)
  | LetRec of string * string (* recursive let binding for functions, let f x = e1 in e2 *)


(* the type for trinary operators, TrinOp (op, e1, e2, e3) *)
type trinOp = 
  | MatchL of string * string (* list matching, match e1 with [] -> e2 | x::xs -> e3 *)
  | Cond (* conditional branching, if e1 then e2 else e3 *)


(* the type of OCaml' expressions*)
type ast = 
  | Base of base
  | UnOp of unOp * ast
  | BinOp of binOp * ast * ast
  | TrinOp of trinOp * ast * ast * ast


(*
 * string_of_base : base -> string
 * REQUIRES: true
 * ENSURES: string_of_base b |-*-> a string representing b
 *)
let string_of_base b = 
  match b with 
  | Int n -> string_of_int n 
  | Bool b -> if b then "true" else "false"
  | Var x -> x 
  | Unit -> "()"
  | Nil -> "[]"


(*
 * string_of_unOp : unOp -> string
 * REQUIRES: true
 * ENSURES: string_of_unOp u |-*-> a string representing u
 *)
let string_of_unOp u = 
  match u with 
  | Not -> "Not"
  | Neg -> "Neg"
  | Fun x -> "Fun{"^x^"}"
  | RecFun (f,x) -> "RecFun{"^f^","^x^"}"


(*
 * string_of_binOp : binOp -> string
 * REQUIRES: true
 * ENSURES: string_of_binOp b |-*-> a string representing b
 *)
let string_of_binOp b = 
  match b with 
  | Add -> "Add"
  | Sub -> "Sub"
  | Mul -> "Mul"
  | Div -> "Div"
  | Eq -> "Eq"
  | Neq -> "Neq"
  | Geq -> "Geq"
  | Leq -> "Leq"
  | Gt -> "Gt"
  | Lt -> "Lt"
  | And -> "And"
  | Or -> "Or"
  | App -> "App"
  | Pair -> "Pair"
  | Cons -> "Cons"
  | MatchP (a,b) -> "MatchP{"^a^","^b^"}"
  | Let x -> "Let{"^x^"}"
  | LetRec (f, x) -> "LetRec{"^f^","^x^"}"


(*
 * string_of_trinOp : trinOp -> string
 * REQUIRES: true
 * ENSURES: string_of_trinOp t |-*-> a string representing t
 *)
let string_of_trinOp t = 
  match t with 
  | MatchL (a,b) -> "MatchL{"^a^","^b^"}"
  | Cond -> "Cond"


(*
 * string_of_ast : ast -> string
 * REQUIRES: true
 * ENSURES: string_of_ast a |-*-> a string representing a
 *)
let rec string_of_ast ast = 
  match ast with 
  | Base b -> string_of_base b 
  | UnOp (u, e) -> string_of_unOp u ^ ("(" ^ string_of_ast e ^ ")")
  | BinOp (b, e1, e2) -> string_of_binOp b ^ ("(" ^ string_of_ast e1 ^ ";" ^ string_of_ast e2 ^ ")")
  | TrinOp (t, e1, e2, e3) -> string_of_trinOp t ^ ("(" ^ string_of_ast e1 ^ ";" ^ string_of_ast e2 ^ ";" ^ string_of_ast e3 ^ ")")